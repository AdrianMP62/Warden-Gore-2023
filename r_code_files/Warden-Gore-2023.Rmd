---
title: "Warden and Gore waterbird analyses 2006-2023"
author: "Adrian Pinder"
date and time: '`r Sys.time()`'
output:
    html_document:
    toc: true
    toc_depth: 4
software: 'RStudio 2022.12.0+353 "Elsbeth Geranium" Release (7d165dcfc1b6d300eb247738db2c7076234f6ef0, 2022-12-03) for Windows: `r getRversion()`'
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: sentence
---

Git repository <https://github.com/AdrianMP62/Warden-Gore-2023>

RStudio 2022.12.0+353 "Elsbeth Geranium" Release (7d165dcfc1b6d300eb247738db2c7076234f6ef0, 2022-12-03) for macOS Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) RStudio/2022.12.0+353 Chrome/102.0.5005.167 Electron/19.1.3 Safari/537.36.
R version: `r getRversion()`\
Date and time: `r Sys.time()`

Uses the following five datafiles:\
\* Warden_Gore_by_suite_06_23.csv (System, SurveyType, SiteName, SiteCode, Subsite Date, CommonName, SpeciesCode, Count) (e.g. Warden, aerial, Neridup Suite, WRP001, combined, 11/10/2006, Great Egret, greg, 1). Note some double counts for Oct 2006 and Feb 2015 removed.

\* Average depths.csv (average depths, rainfall variables and pipeline operation and timing of surveys of Warden wetlands for each survey period).

\* Taxonomy (CommonName, Order and informal group name in consecutive columns. CommonNames match those in Warden_Gore_by_suite_06_19.csv)

\* Warden depths.csv (Average depth of warden wetlands, cumulative deviations from monthly means, days pipeline open in prior 3 months and timing of spring and summer surveys.

\* Rain for regr.csv CDM from 3 weather stations to model for missing values.

Date and time: `r Sys.time()`

```{r setup, echo=FALSE}
#knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(message = FALSE)
#knitr::opts_chunk$set(include = FALSE)
knitr::opts_knit$set(root.dir = '../') 
```

```{r}
options(scipen=999) #  prevent-scientific notation for numbers
```

```{r}
set.seed(1234)
```

```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load("plot3D","datawizard","scatterplot3d","plot3Drgl","gridExtra","vegan","tidyr","ggplot2","openxlsx2", "rgl", "ggrepel", "dplyr", "plyr", "scales", "ggpubr", "stringr","reshape2", "knitr", "zoo", "car","reshape2","readxl","lubridate","Rcpp")
```

```{r}
source("./functions/bio_env_ext.R") #The Bio_env and bv_step_ext routines below comes from http://menugget.blogspot.com.au/2011/06/clarke-and-ainsworths-bioenv-and-bvstep.html
source("./functions/bv_step_ext.R")
source("./functions/bv.step.R")
source("./functions/extract_legend.R")
```

#ANALYSES OF WATERBIRD DATA FROM THE WARDEN AND GORE WETLAND SYSTEMS 2006 TO 2023

The following is the output from an Rmarkdown R script for analyses of waterbird communities of the Warden and Gore wetland systems surveyed between Oct 2006 and Feb 2023.

These analyses are based primarily on ground counts.
Aerial counts are only for a few Warden system wetlands in 2006 to 2009 where ground counts were not undertaken.
These include Neridup and Bandy Creek (Oct 2006-Nov 2008), Ewans (Oct 2006) and Ewans and Mullet combined (Nov 2008 - have to ignore Nov 2008 Mullet ground counts), North Wheatfield (Oct 2006, Oct 2007, Nov 2008).
Note that the Nov 2008 aerial data was collected two weeks prior to the ground counts.
Gore data is included only for November 2009 onwards when ground counts are available.
Some replicate count data for Oct 2006 and Feb 2015 (North Wheatfield) are excluded from the dataset above prior to import.
Pink Lake is excluded from analyses because it wasnt consistently surveyed.
Birds counted only while in air and not allocated to any particular wetland are given the site code 'In flight'.
These conditions apply to all following analyses.

##IMPORT BASIC DATA AND FORMAT COLUMNS

```{r}
#create data table with unidentified birds included - for column plots of
input.data <- read.csv("./raw_data/Warden_Gore_by_suite_06_23.csv")
  input.data <- input.data[-grep("Grassbird", input.data$CommonName), ] #remove records of little grassbird
  input.data$Date <- as.Date(input.data$Date, format="%d/%m/%Y")
  input.data$Survey <- input.data$Date #create Survey field from Date
  input.data$Survey <- format(as.Date(input.data$Survey), "%b-%Y") #change format to mmm-YYYY
  input.data$Survey <- gsub("Oct-2018", "Nov-2018", input.data$Survey) #lump survey dates that straddle Oct/Nov 2018 and call Nov-2018
  input.data$Survey <- gsub("Oct-2022", "Nov-2022", input.data$Survey) #lump survey dates that straddle Oct/Nov 2022 and call Nov-2022
  yq <- as.yearqtr(as.yearmon(input.data$Date, "%Y/%m/%d"))
  input.data$Season <- factor(format(yq, "%q"), levels = 1:4, labels = c("summer", "autumn", "winter", "spring")) #create Season (spring vs summer) variable
  input.data$Sys_Sur <- paste(input.data$System, input.data$Survey, sep = " ") # combine System and date to create one 'sample' variable for mds - i.e. combine system with season
  input.data <- input.data[-grep("No birds", input.data$CommonName), ] #remove rows where wetland surveyed but no birds present or where wetlands dry
input.data <- input.data[-grep("No data collected", input.data$CommonName), ] #remove rows where wetland not surveyed
#import taxonomic nomenclature table
input.data.2 <- input.data[-grep("Unidentified", input.data$CommonName), ] #remove rows where birds not identified and save as a separate file

#import taxonomic nomenclature table
Taxonomy <- read.csv("./raw_data/Taxonomy.csv")
```

##ANALYSES OF WARDEN AND GORE COMBINED

### Create species x year matrix

```{r}
#create W+G matrix
input.data.2$Year <- year(input.data.2$Date)
WG_SxY <- as.matrix(xtabs(input.data.2$Count ~ input.data.2$CommonName + input.data.2$Survey))
write.csv(WG_SxY, "./outputs/WG_SxY.csv")
```

###Stacked abundance column plots

```{r}
#Create data file and exclude 2006 to 2008 surveys because no ground counts at Gore.
WG.stack <- input.data
WG.stack <- filter(WG.stack, Survey != "Oct-2006" & Survey != "Oct-2007" & Survey != "Nov-2008" & Survey != "Feb-2008")
#add variable for taxonomic group
WG.stack$Group <- Taxonomy[match(WG.stack$CommonName, Taxonomy$CommonName), 3]
```

```{r}
#Aggregate data by taxonomic group and survey, with survey and season variables for plotting, plus add dummy dates for years not surveyed
WG.stack.agg <- aggregate(data=WG.stack, Count ~ Group + Survey + Season, FUN="sum") #aggregate count data by species and survey
#create dummy data for missing survey years for spring and summer
md.Group <- rep("Grebes", times = 9)
md.Survey <- c("Nov-2015","Nov-2016","Nov-2017","Nov-2019","Feb-2016","Feb-2017","Feb-2018","Feb-2020","Feb-2022")
md.Season <- c(rep("spring", times = 4), rep("summer", times = 5))
md.Count <- rep(0, times = 9)
Missing.dates <- data.frame(md.Group, md.Survey, md.Season, md.Count)
colnames(Missing.dates) <- c("Group","Survey","Season","Count")
WG.stack.agg <- rbind(WG.stack.agg, Missing.dates)
WG.stack.agg$SurvOrd <- as.character(WG.stack.agg$Survey)
WG.stack.agg$SurvOrd <- as.numeric(str_replace_all(WG.stack.agg$SurvOrd, c("Feb-2008" = "1", "Feb-2010" = "2", "Feb-2011" = "3", "Feb-2012" = "4", "Feb-2013" = "5", "Feb-2014" = "6", "Feb-2015" = "7", "Feb-2016" = "8", "Feb-2017" = "9", "Feb-2018" = "10", "Feb-2019" = "11", "Feb-2020" = "12", "Feb-2021" = "13", "Feb-2022" = "14", "Feb-2023" = "15", "Oct-2006" = "1", "Oct-2007" = "2", "Nov-2008" = "3", "Nov-2009" = "4", "Nov-2010" = "5", "Dec-2011" = "6", "Oct-2012" = "7", "Nov-2013"= "8", "Nov-2014" = "9", "Nov-2015" = "10", "Nov-2016" = "11", "Nov-2017" = "12", "Nov-2018" = "13", "Nov-2019" = "14", "Nov-2020" = "15", "Nov-2022" = "16")))
```

```{r}
#stacked column plots for Warden+Gore by season
#spring
WG.stack.spr <- WG.stack.agg[WG.stack.agg$Season=="spring", ] #cut down to just spring data
WG.stack.spr <- WG.stack.spr[ order(WG.stack.spr$SurvOrd), ]
ggplot(WG.stack.spr, aes(x=reorder(Survey, SurvOrd), y=Count, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,50000, by=5000), limits=c(0,50000)) + labs(x="Survey", y="Abundance") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(size = 20, margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(size = 20, margin = margin(t = 20, r = 0, b = 0, l = 0))) + theme(axis.text.x = element_text(size=12)) + theme(axis.text.y = element_text(size=15)) + scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#A2B5CD","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A"))

#summer
WG.stack.sum <- WG.stack.agg[WG.stack.agg$Season=="summer", ] #cut down to just summer data
WG.stack.sum <- WG.stack.sum[ order(WG.stack.sum$SurvOrd), ]
ggplot(WG.stack.sum, aes(x=reorder(Survey, SurvOrd), y=Count, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,50000, by=5000), limits=c(0,50000)) + labs(x="Survey", y="Abundance") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(size = 20, margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(size = 20, margin = margin(t = 20, r = 0, b = 0, l = 0))) + theme(axis.text.x = element_text(size=12)) + theme(axis.text.y = element_text(size=15)) + scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#A2B5CD","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A")) #uses Date to reorder survey on x axis
```

###Multivariate analyses

####Contrast season with Warden and Gore combined

```{r}
#input data and remove 2006 to 2008 data
WG.bySeason <- input.data.2
WG.bySeason = filter(WG.bySeason, Survey != "Oct-2006" & Survey != "Oct-2007" & Survey != "Nov-2008" & Survey != "Feb-2008")
```

```{r}
#Aggregate data by Season and create matrix
WG.bySeason.agg <- aggregate(data=WG.bySeason, Count ~ CommonName + Survey + Season, FUN="sum") #sum data by common name and survey period
```

```{r}
# Create matrix for ordination
WG.bySeason.m <- spread(WG.bySeason.agg, CommonName, Count)
rownames(WG.bySeason.m) <- WG.bySeason.m[,1]
  WG.bySeason.m[,1] <- NULL
  WG.bySeason.m[is.na(WG.bySeason.m)] <- 0
   WG.bySeason.m [,1] <- NULL #remove season column
  #WG.bySeason.m[, 1-75] <- sqrt(WG.bySeason.m[, 1-75])
```

```{r}
#Extract survey and season variables for ordination plots
surv.seas <- unique(WG.bySeason[c("Survey", "Season")]) #extract a unique list of survey codes (mmm-yy) and season so can later allocate a season to each survey in the MDS output
surv.seas <- surv.seas[order(surv.seas$Survey), ] #reorder alphabetically by Survey (Dec-2011 to Oct-2012)
```

```{r}
#Run 2D ordination
WG.MDS.bySeas <- metaMDS(WG.bySeason.m, distance = "bray")
```

```{r}
#Extract ordination axis coordinates
  WG.MDS.bySeas.pts <- as.data.frame(WG.MDS.bySeas$points) #extract 2D ordination coordinates (points)
  WG.MDS.bySeas.pts$Survey <- row.names(WG.MDS.bySeas.pts) #use survey period as row.names
  WG.MDS.bySeas.pts$Season <- surv.seas[match(WG.MDS.bySeas.pts$Survey, surv.seas$Survey), 2] #adds 'season' (spring versus summer) (from column '2' of Surv.Seas) to ordination points by matching survey between points and surv.seas
```

The ordination below shows that, with data from systems (Warden and Gore) combined, there is some difference between waterbird communities present in spring and those present in late summer, with summer surveys generally to the right and/or below the previous spring surveys.

```{r}
#2D ordination plot of Warden and Gore data combined by season
Xmin <- min(WG.MDS.bySeas.pts$MDS1)*1.2
Xmax <- max(WG.MDS.bySeas.pts$MDS1)*1.2
Ymin <- min(WG.MDS.bySeas.pts$MDS2)*1.2
Ymax <- max(WG.MDS.bySeas.pts$MDS2)*1.2
ggplot(WG.MDS.bySeas.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin,Xmax) + ylim(Ymin,Ymax) + geom_point(aes(colour=Season), size=5) + coord_fixed(ratio = 1) + geom_text(aes(label=Survey), size=3, vjust=1, hjust=1.3)
```

However, the stress value of the above ordination is high at `r WG.MDS.bySeas$stress`, so a 3D ordination was also produced.

```{r}
# 3D ordination
WG.3dMDS.bySeas <- metaMDS(WG.bySeason.m, distance = "bray", k=3)
```

```{r}
#Extract ordination axis coordinates
  WG.3dMDS.bySeas.pts <- as.data.frame(WG.3dMDS.bySeas$points) #extract 3D ordination coordinates (points)
  WG.3dMDS.bySeas.pts$Survey <- row.names(WG.3dMDS.bySeas.pts) #use survey period as row.names
  WG.3dMDS.bySeas.pts$Season <- surv.seas[match(WG.3dMDS.bySeas.pts$Survey, surv.seas$Survey), 2] #adds 'season' (spring versus summer) (from column '2' of Surv.Seas) to ordination points by matching survey between points and surv.seas
```

3D ordination stress = `r WG.3dMDS.bySeas$stress`.

```{r}
Xmin <- min(WG.3dMDS.bySeas.pts$MDS1)*1.3
Xmax <- max(WG.3dMDS.bySeas.pts$MDS1)*1.3
Ymin <- min(WG.3dMDS.bySeas.pts$MDS3)*1.3
Ymax <- max(WG.3dMDS.bySeas.pts$MDS3)*1.3
ggplot(WG.3dMDS.bySeas.pts, aes(x=MDS1, y=MDS2)) + xlim(Xmin, Xmax) + ylim(Ymin, Ymax) + geom_point(aes(colour=Season), size=5) + coord_fixed(ratio = 1) + geom_text(aes(label=Survey), size=3, vjust=1, hjust=1.3) + theme (plot.margin=unit(c(0,0,0,5),"mm"))
```

### 'Simper' analysis to extract a short-list of species most responsible for the differences between seasons

```{r}
  WG.bySeas.Simper <- simper(WG.bySeason.m, surv.seas$Season) #Simper analysis to determine which species best correlated with differences between seasons of whole dataset
```

```{r}
#Extract top 8 species names from the Simper analysis
  WG.Simper.ext <- WG.bySeas.Simper$spring_summer #extract results from Simper analysis
  WG.Sim.Average <- as.data.frame(WG.Simper.ext$average) #extract the average difference data
  WG.Sim.Spec <- as.data.frame(WG.Simper.ext$species) #extract species names
  WG.bySeas.Simper2 <- cbind(WG.Sim.Spec, WG.Sim.Average) #combine species with averages
  WG.bySeas.Simper2 <- WG.bySeas.Simper2[ order(-WG.bySeas.Simper2[, 2]), ] #order species and averages by average
colnames(WG.bySeas.Simper2) = c("Species", "cont") #add new column names
  WG.bySeas.Simper2 <- as.vector(WG.bySeas.Simper2[1:8, 1]) #extracts top 8 species names
```

```{r}
#Aggregate species x site listing by season, survey and common name to later extract data for just the 8 species
  agg.spec.data <- aggregate(data=WG.bySeason, Count ~ CommonName + Season + Survey, FUN="sum") #aggregate counts by common name, season and survey
  #agg.spec.data <- as.data.frame(sapply(agg.spec.data, gsub, pattern = "-", replacement = " ")) #replace dashes with spaces
```

```{r}
#Extract top 8 species from aggregated data
  agg.spec.data.8 <- agg.spec.data[agg.spec.data$CommonName %in% WG.bySeas.Simper2, ]
  rownames(agg.spec.data.8) <- NULL #reset row names
  agg.spec.data.8 <- as.data.frame(agg.spec.data.8[, -3]) #remove Survey field
  agg.spec.data.8$CommonName <- as.character(agg.spec.data.8$CommonName)
  write.csv(agg.spec.data.8, "./outputs/agg.spec.data.8.csv")
  agg.spec.data.8 <- read.csv("./outputs/agg.spec.data.8.csv")
```

```{r}
#box plots These box plots show the abundance of the top 8 species contributing to waterbird communities being different in spring and summer (Gore and Warden systems combined).
  qplot(x=Season, y=Count, data=agg.spec.data.8, geom="boxplot") + facet_wrap(~ CommonName, scales="free_y", ncol=2)
```

####Ordination of Warden versus Gore in both seasons

```{r}
WG.bySystem <- input.data.2
WG.bySystem = filter(WG.bySystem, Survey != "Oct-2006" & Survey != "Oct-2007" & Survey != "Nov-2008" & Survey != "Feb-2008")
```

```{r}
# Aggregate data by species and system/survey
WG.bySystem.agg <- aggregate(data=WG.bySystem, Count ~ CommonName + Sys_Sur, FUN="sum")
```

```{r}
# Create matrix for ordination
WG.bySystem.m <- spread(WG.bySystem.agg, CommonName, Count)
rownames(WG.bySystem.m) <- WG.bySystem.m[,1]
  WG.bySystem.m[,1] <- NULL
  WG.bySystem.m[is.na(WG.bySystem.m)] <- 0
  #WG.bySystem.m[, 1-75] <- sqrt(WG.bySystem.m[, 1-75])
```

```{r}
# MDS unconstrained ordination using metaMDS in package vegan to compare Warden and Gore wetland systems
WG.MDS.bySyst <- metaMDS(WG.bySystem.m, try=100, distance = "bray")
```

```{r}
# Extract coordinates from ordination and add season to data frame for Warden vs Gore analysis
system <- unique(input.data.2$System) #extract a unique list of systems (Gore, Warden)
WG.MDS.bySyst.pts <- as.data.frame(WG.MDS.bySyst$points) #extract coordinates from metaMDS
WG.MDS.bySyst.pts$Sys_Sur <- row.names(WG.MDS.bySyst.pts) #use row.names to create new System+Survey period variable
WG.MDS.bySyst.pts$Survey <- str_sub(WG.MDS.bySyst.pts$Sys_Sur, -8, -1) #extract Survey period from Sys-Sur variable by extracting last 8 characters
WG.MDS.bySyst.pts$System <- substr(WG.MDS.bySyst.pts$Sys_Sur, 1, 4) #extract System from Sur-sys variable by extracting first 4 variables
WG.MDS.bySyst.pts$System <- gsub("Ward", "Warden", WG.MDS.bySyst.pts$System) #convert 'Ward' to 'Warden'
#WG.MDS.bySyst.pts <- WG.MDS.bySyst.pts[with(WG.MDS.bySyst.pts, order(Survey)), ] #order by survey
WG.MDS.bySyst.pts$Season <-  substr(WG.MDS.bySyst.pts$Survey, 1, 3) #extract months
WG.MDS.bySyst.pts$Season <- recode(WG.MDS.bySyst.pts$Season, "'Feb'='summer';c('Dec','Oct','Nov')='spring'") #convert months to season
WG.MDS.bySyst.pts$SystSeas <- paste(WG.MDS.bySyst.pts$System, WG.MDS.bySyst.pts$Season, sep=" in ")
str(WG.MDS.bySyst.pts) #join System and season
```

```{r}
#plot of 2D W and G spr and sum ordination
ggplot(WG.MDS.bySyst.pts, aes(x=MDS1, y=MDS2, shape=SystSeas, colour=SystSeas)) + xlim(min(WG.MDS.bySyst.pts$MDS1)*1.3, max(WG.MDS.bySyst.pts$MDS1)*1.3) + ylim(min(WG.MDS.bySyst.pts$MDS2)*1.3, max(WG.MDS.bySyst.pts$MDS2)*1.3) + coord_fixed(ratio = 1) + geom_point(size=5) + scale_color_manual(values=c("blue","blue","red","red")) + scale_shape_manual(values=c(0,15,2,17)) + geom_text(aes(label=Survey), colour="black", size=3, vjust=1, hjust=1.3)
```

However, the stress level of the above two-dimensional ordintion is unacceptably high at `r WG.MDS.bySyst$stress`.
A three-dimensional ordination was therefore undertaken.

```{r}
#3D MDS unconstrained ordination using metaMDS in package vegan to compare Warden and Gore wetland systems
WG.3dMDS.bySyst <- metaMDS(WG.bySystem.m, distance = "bray", k=3, transform="false")
```

```{r}
# Extract coordinates from 3D ordination and add season to data frame for Warden vs Gore analysis
system <- unique(input.data.2$System) #extract a unique list of systems (Gore, Warden)
WG.3dMDS.bySyst.pts <- as.data.frame(WG.3dMDS.bySyst$points) #extract coordinates from metaMDS
WG.3dMDS.bySyst.pts$Sys_Sur <- row.names(WG.3dMDS.bySyst.pts) #use row.names to create new System+Survey period variable
WG.3dMDS.bySyst.pts$Survey <- str_sub(WG.3dMDS.bySyst.pts$Sys_Sur, -8, -1) #extract Survey period from Sys-Sur variable by extracting last 8 characters
WG.3dMDS.bySyst.pts$System <- substr(WG.3dMDS.bySyst.pts$Sys_Sur, 1, 4) #extract System from Sur-sys variable by extracting first 4 variables
WG.3dMDS.bySyst.pts$System <- gsub("Ward", "Warden", WG.3dMDS.bySyst.pts$System) #convert 'Ward' to 'Warden'
#WG.3dMDS.bySyst.pts <- WG.3dMDS.bySyst.pts[with(WG.3dMDS.bySyst.pts, order(Survey)), ] #order by survey
WG.3dMDS.bySyst.pts$Season <-  substr(WG.3dMDS.bySyst.pts$Survey, 1, 3) #extract months
WG.3dMDS.bySyst.pts$Season <- recode(WG.3dMDS.bySyst.pts$Season, "'Feb'='summer';c('Dec','Oct','Nov')='spring'") #convert months to season
WG.3dMDS.bySyst.pts$SystSeas <- paste(WG.3dMDS.bySyst.pts$System, WG.3dMDS.bySyst.pts$Season, sep=" in ")
```

The ordination plot below shows that the Warden and Gore wetland systems consistently support different waterbird communities, i.e. for waterbirds they have different conservation values.
It can also be seen that there is greater seasonal differences in the Warden system than in the Gore system (i.e. greater overlap between positions of the summer and spring surveys amongst the Gore surveys).

the Nov 2018 and Feb 2019 surveys are within the range of community compositions surveyed since 2006 for both systems, despite the very high counts in Feb 2019 and low Warden count in Nov 2018.

```{r}
# plot of 3D Warden vs Gore by season ordination
ggplot(WG.3dMDS.bySyst.pts, aes(x=MDS1, y=MDS2, shape=SystSeas, colour=SystSeas)) + xlim(min(WG.3dMDS.bySyst.pts$MDS1)*1.3,max(WG.3dMDS.bySyst.pts$MDS1)*1.3) + ylim(min(WG.3dMDS.bySyst.pts$MDS2)*1.3,max(WG.3dMDS.bySyst.pts$MDS2)*1.3) + coord_fixed(ratio = 1) + geom_point(size=5) + scale_color_manual(values=c("blue","blue","red","red")) + scale_shape_manual(values=c(0,15,2,17)) + theme(legend.title = element_blank()) + theme(legend.position = "top") + theme(legend.text=element_text(size=12)) + theme(plot.margin=unit(c(0,0,0,0),"mm")) + geom_text(aes(label=Survey), colour="black", size=3, vjust=1, hjust=1.3)
```

#### Simper analysis to extract species separating Warden versus Gore

```{r}
  WG.bySyst.Sim <- simper(WG.bySystem.m, WG.3dMDS.bySyst.pts$System) #Simper analysis to determine which species best correlated with differences between systems
summary(WG.bySyst.Sim, ordered=TRUE)
```

```{r}
# Extract the top 10 species from the Simper analysis
  WG.bySyst.Sim.ext <- WG.bySyst.Sim$Gore_Warden #extract name and contribution data from simper analysis
  WG.bySyst.Sim.average <- as.data.frame(WG.bySyst.Sim.ext$average)#extract average contribution values
  WG.bySyst.Sim.spec <- as.data.frame(WG.bySyst.Sim.ext$species)#extract species names
  WG.bySyst.Sim.ext <- cbind(WG.bySyst.Sim.spec, WG.bySyst.Sim.average) #combine average with species name
  WG.bySyst.Sim.ext <- WG.bySyst.Sim.ext[ order(-WG.bySyst.Sim.ext[,2]), ] #order by average value
colnames(WG.bySyst.Sim.ext) = c("Species", "cont") #add new column names
  WG.bySyst.Sim.ext <- as.vector(WG.bySyst.Sim.ext[1:10, 1]) #extract top 10 species: first 10 rows
  #WG.bySyst.Sim.ext <- gsub("\\.", " ", WG.bySyst.Sim.ext)
  WG.bySyst.Sim.ext
```

```{r}
# Extract count data for top 10 species
agg.spec.data.2 <- aggregate(data=WG.bySystem, Count ~ CommonName + Survey + System, FUN="sum") #aggregare count data by system and survey
#agg.spec.data.2 <- as.data.frame(sapply(agg.spec.data.2, gsub, pattern = "-", replacement = " ")) #replace dashes in species names with spaces to match simper output
agg.spec.data.2 <- agg.spec.data.2[agg.spec.data.2$CommonName %in% WG.bySyst.Sim.ext, ] #restrict aggregated counts to just those top 8 species from simper
rownames(agg.spec.data.2) <- NULL
agg.spec.data.2$CommonName <- as.character(agg.spec.data.2$CommonName)
colnames(agg.spec.data.2)[4] <- "Abundance"
write.csv(agg.spec.data.2, "./outputs/agg.spec.data.2.csv")
agg.spec.data.2 <- read.csv("./outputs/agg.spec.data.2.csv")
```

```{r}
# Box plots for Warden v Gore for the top 10 simper species
qplot(x=System, y=Abundance, data=agg.spec.data.2, geom="boxplot") + facet_wrap(~ CommonName, scales="free_y", ncol=2) + theme(axis.title.y = element_text(hjust=0.5)) #produce facet wrapped box plots showing differences in top 10 simper species by wetland system
```

```{r}
# Undertake Mann-Whitney for each of the 10 top Simper species and combine results into file called ttest.results
WG.bySyst.Sim.ext <- WG.bySyst.Sim.ext[-8]
WG.bySyst.Sim.ext
ttest.v <- vector()
for (i in 1:9) {
tt.data <- subset(agg.spec.data.2, CommonName == WG.bySyst.Sim.ext[i])
print(ttest <- wilcox.test(log10(Abundance) ~ System, data = tt.data))
ttest.v <- c(ttest.v, ttest$p.value)
}
ttest.v
ttest.results <- data.frame(CommonName=WG.bySyst.Sim.ext, p.value=ttest.v)
ttest.results
```

##WARDEN SYSTEM ANALYSIS ONLY

###Regressions of Esperance rainfall Station data to fill missing values

```{r}
#need to switch variables (weather stations) depending on which regression required
raincheck <- read.csv("./raw_data/rain for regr.csv")
fit <- lm(raincheck$ESPA ~ sqrt(raincheck$ESPE) + sqrt(raincheck$MYRU))
plot(fit)
summary(fit)
plot(sqrt(raincheck$ESPE), -38.9234+(5.3525*sqrt(raincheck$ESPE))+(8.433*sqrt(raincheck$ESPA)))
```

###Graphing lake depths

```{r}
#Load depth data and convert to AHD
Wdepths <- read.csv("./raw_data/Warden depths.csv") #note: all values of "dry", "pooling" and "below DG" counted as zero depth. Missing values retained.
Wdepths[, c(2:7)] <- round(Wdepths[, c(2:7)], digits = 2)
# create year and month variables
str(Wdepths)
Wdepths$Date <- as.Date(Wdepths$Date, format = "%d/%m/%Y")
Wdepths$month <- month(Wdepths$Date)
Wdepths$year <- as.factor(year(Wdepths$Date))
Wdepths$year <- as.factor(Wdepths$year)
Wdepths$doy <- as.numeric(strftime(Wdepths$Date, format = "%j")) #create day of year variable
```

```{r}
#Extract and graph Ewans dataset
Wdepths_Ewans <- Wdepths[, c("Ewans","year","doy")] #extract Ewans data
Wdepths_Ewans <- na.omit(Wdepths_Ewans) #remove NAs
#graph data)
ggplot(Wdepths_Ewans, aes(x=doy, y=Ewans, color=year)) + 
  geom_line() +
  geom_point(cex=4) +
  scale_color_manual(values=c('grey','grey','grey','grey','grey','grey','grey','grey','grey','grey','grey','grey','grey','grey',"grey",'grey','orange','blue','red','yellow','purple')) +
    ggtitle("Ewans annual depths") +
    theme(plot.title = element_text(vjust = -10)) +
    theme(plot.title = element_text(hjust = 0.5)) +
    ylab("Depth (m)") +
    xlab("Days in Year") +
    theme(axis.title.x =element_text(size=14, vjust=-0.5)) +
    theme(axis.title.y =element_text(size=14)) +
    theme(axis.text=element_text(size=14))
```

```{r}
#Extract and graph Wheatfield dataset
Wdepths_Wheat <- Wdepths[, c("Wheatfield","year","doy")] #extract Wheatfield data
Wdepths_Wheat <- na.omit(Wdepths_Wheat) #remove NAs
#graph data)
ggplot(Wdepths_Wheat, aes(x=doy, y=Wheatfield, color=year)) + 
  geom_line() +
  geom_point(cex = 4) +
  scale_color_manual(values=c('grey','grey',"grey",'grey','grey','grey','grey','grey','grey','green','grey','grey','grey','grey','grey',"grey",'grey','grey','blue','red','yellow','purple')) +
    ggtitle("Wheatfield annual depths") +
    theme(plot.title = element_text(vjust = -10)) +
    theme(plot.title = element_text(hjust = 0.5)) +
    ylab("Depth (m)") +
    xlab("Days in Year") +
    theme(axis.title.x =element_text(size=14, vjust=-0.5)) +
    theme(axis.title.y =element_text(size=14)) +
    theme(axis.text=element_text(size=14))
```

```{r}
#Extract and graph Warden dataset
Wdepths_Ward <- Wdepths[, c("Warden","year","doy")] #extract Warden data
Wdepths_Ward <- na.omit(Wdepths_Ward) #remove NAs
#graph data)
ggplot(Wdepths_Ward, aes(x=doy, y=Warden, color=year)) + 
  geom_line() +
  geom_point(cex = 4) +
  scale_color_manual(values=c('grey','grey',"grey",'grey','grey','grey','grey','grey','grey','grey','grey','grey','grey','grey','grey',"grey",'grey','orange','blue','red','yellow','purple')) +
    ggtitle("Warden annual depths") +
    theme(plot.title = element_text(vjust = -10)) +
    theme(plot.title = element_text(hjust = 0.5)) +
    ylab("Depth (m)") +
    xlab("Days in Year") +
    theme(axis.title=element_text(size=14)) +
    theme(axis.title.x =element_text(size=14, vjust=-0.5)) +
    theme(axis.title.y =element_text(size=14)) +
    theme(axis.text=element_text(size=14))
```

###Totals of species abundances x year (for spring)

```{r}
#spring
Warden <- input.data[input.data$System == "Warden", ]
Warden <- Warden[Warden$Season == "spring", ]
Warden$Year <- year(Warden$Date)
Warden_SxY <- as.matrix(xtabs(Warden$Count ~ Warden$CommonName + Warden$Year))
Warden_SxY
write.csv(Warden_SxY, "./outputs/Warden_SxY_spr.csv")

#summer
Warden <- input.data[input.data$System == "Warden", ]
Warden <- Warden[Warden$Season == "summer", ]
Warden$Year <- year(Warden$Date)
Warden_SxY <- as.matrix(xtabs(Warden$Count ~ Warden$CommonName + Warden$Year))
Warden_SxY
write.csv(Warden_SxY, "./outputs/Warden_SxY_sum.csv")
```

###Ordinations and associated analyses

```{r}
#Input waterbird data and split into spring and summer datasets, including creating a survey variable
Warden <- input.data.2[input.data.2$System == "Warden", ]
  Warden.sum <- Warden[Warden$Season == "summer", ] #summer only data
  Warden.spr <- Warden[Warden$Season == "spring", ] #spring only data
```

```{r}
#Create a matrix for checking counts - this not used in analysis
Warden_matrix <- acast(Warden, CommonName ~ Survey, value.var="Count", fun.aggregate = sum) #sums counts for each species and survey
write.csv(Warden_matrix, "./outputs/Warden_matrix.csv")
```

```{r}
#Aggregate count data by just common name and survey for creating season matrices
Warden.sum.agg <- aggregate(data=Warden.sum, Count ~ CommonName + Survey, FUN="sum") #aggregate count data by species and survey
#Warden.sum.agg$Count <- sqrt(Warden.sum.agg$Count) removed sqrt because metaMDS routine in vegan transforms species abundance data is required.
Warden.spr.agg<- aggregate(data=Warden.spr, Count ~ CommonName + Survey, FUN="sum") #aggregate count data by species and survey
#Warden.spr.agg$Count <- sqrt(Warden.spr.agg$Count) removed sqrt because metaMDS routine in vegan transforms species abundance data is required.
```

```{r}
#Create waterbird matrices by season

#summer
Warden.sum.m <- melt(Warden.sum.agg)
Warden.sum.m <- dcast(Warden.sum.m, Survey ~ CommonName, fill="0")
rownames(Warden.sum.m) <- Warden.sum.m[,1]
Warden.sum.m[,1] <- NULL
write.csv(Warden.sum.m, "./outputs/Warden_sum_m.csv")
Warden.sum.m <- read.csv("./outputs/Warden_sum_m.csv", row.names=1)

#spring
Warden.spr.m <- melt(Warden.spr.agg)
Warden.spr.m <- dcast(Warden.spr.m, Survey ~ CommonName, fill="0")
rownames(Warden.spr.m) <- Warden.spr.m[,1]
Warden.spr.m[,1] <- NULL
write.csv(Warden.spr.m, "./outputs/Warden_spr_m.csv")
Warden.spr.m <- read.csv("./outputs/Warden_spr_m.csv", row.names=1)
```

```{r}
#Cluster analysis of Warden data

#spring
Warden.spr.bray <- vegdist(Warden.spr.m, method = "bray")
Warden.spr.clust <- hclust(Warden.spr.bray, method = "complete")
plot(Warden.spr.clust)

#summer
Warden.sum.bray <- vegdist(Warden.sum.m, method = "bray")
Warden.sum.clust <- hclust(Warden.sum.bray, method = "complete")
plot(Warden.sum.clust)
```

```{r}
#MDS unconstrained ordination using metaMDS in package vegan to analyse effects of season within the Warden system
Warden.sum.MDS <- metaMDS(Warden.sum.m, distance = "bray", transform = FALSE)
#note stress for summer is OK
Warden.spr.MDS <- metaMDS(Warden.spr.m, distance = "bray", transform = FALSE)
#note stress for spring too high at 0.16, so need to repeat with 3D
Warden.spr.MDS <- metaMDS(Warden.spr.m, distance = "bray", k=3, transform = FALSE)
```

```{r}
#Extract ordination point data for ggplots
Warden.sum.MDS.pts <- as.data.frame(Warden.sum.MDS$points) #extract coordinates from ordination
Warden.sum.MDS.pts$Survey <- row.names(Warden.sum.MDS.pts)
Warden.spr.MDS.pts <- as.data.frame(Warden.spr.MDS$points) #extract coordinates from ordination
Warden.spr.MDS.pts$Survey <- row.names(Warden.spr.MDS.pts)
Warden.spr.MDS.pts$Cluster <- c(2,2,2,3,3,2,3,1,1,2,2,3)
#W.points$season <- c("spring","summer","summer","summer","summer","summer","summer","summer","spring","spring","spring","spring","spring","spring","spring","spring") # add season labels as new column in dataframe
```

###Start loading and formatting environmental data so can plot ordinations by depth

```{r}
#Load environmental data, extract pipeline operation days and create seasonal env matrices (for pipeline days only and for depth and other data)
#ensure surveys are in text format in the 'average depths.csv' file.
av.depths <- read.csv("./raw_data/average depths.csv") #load data file with average depths (per survey) for gauged Warden wetlands plus other env data
av.depths <- av.depths[order(av.depths$Survey), ] # order data by survey
row.names(av.depths) <- av.depths$Survey
av.depths <- av.depths[order(av.depths$Season, av.depths$Survey), ] #order alphabetically by season then survey
Surv.spr <- av.depths[av.depths$Season == "Spring", "Days", drop=FALSE]
Surv.sum <- av.depths[av.depths$Season == "Summer", "Days", drop=FALSE]
Surv.Pipe.spr <- av.depths[av.depths$Season == "Spring", c("Pipeline_days","Days"), drop=FALSE]
Surv.Pipe.sum <- av.depths[av.depths$Season == "Summer", c("Pipeline_days","Days"), drop=FALSE]
Pipeline.spr <- av.depths[av.depths$Season == "Spring", "Pipeline_days", drop=FALSE]
Pipeline.sum <- av.depths[av.depths$Season == "Summer", "Pipeline_days", drop=FALSE]
av.depths$Pipeline_days <- NULL #remove pipeline data from av.depths
av.depths$Days<-NULL
av.depths$Month <- NULL
BEdat.spr <- av.depths[av.depths$Season == "Spring", 3:ncol(av.depths)] #restrict av.depths to spring
BEdat.spr <- BEdat.spr[ order(row.names(BEdat.spr)), ]
row.names(BEdat.spr) <- row.names(av.depths[av.depths$Season == "Spring", ])
BEdat.spr2 <- BEdat.spr #copy env data for spring
BEdat.spr2$Pipeline_days <- Pipeline.spr$Pipeline_days #add spring pipeline data 
BEdat.sum <- av.depths[av.depths$Season == "Summer", 3:ncol(av.depths)] #restrict av.depths to summer
row.names(BEdat.sum) <- row.names(av.depths[av.depths$Season == "Summer", ])
BEdat.sum2 <- BEdat.sum #copy env data for spring
BEdat.sum2$Pipeline_days <- Pipeline.sum$Pipeline_days #add spring pipeline data 
```

```{r}
#Produce environmental data correlation matrices
cor(BEdat.spr, method="pearson")
cor(BEdat.sum, method="pearson")
```

```{r}
#Range standardise env data without pipeline data

#spring
BEdat.spr.st <-BEdat.spr
for (i in 1:ncol(BEdat.spr)){
  BEdat.spr.st[, i] <- rescale(BEdat.spr[, i], to = c(0,1))
}
Pipeline.spr$Pipeline_days_st <- rescale(Pipeline.spr$Pipeline_days, to = c(0,1))

#summer
BEdat.sum.st <-BEdat.sum
for (i in 1:ncol(BEdat.sum)){
  BEdat.sum.st[, i] <- rescale(BEdat.sum[, i], to = c(0,1))
}
Pipeline.sum$Pipeline_days_st <- rescale(Pipeline.sum$Pipeline_days, to = c(0,1))
```

```{r}
#Range standardise env data with pipeline
BEdat.spr.st2 <-BEdat.spr2
for (i in 1:ncol(BEdat.spr2)){
  BEdat.spr.st2[, i] <- rescale(BEdat.spr2[, i], to = c(0,1))
}
Surv.Pipe.spr$Days.st <- rescale(Surv.Pipe.spr$Days, to = c(0,1))
Surv.Pipe.sum$Days.st <- rescale(Surv.Pipe.sum$Days, to = c(0,1))
```

```{r}
#Ordination graphs of Warden system waterbird communities by survey with surveys undertaken in spring and summer scaled and coloured by average depth of gauged wetlands

#summer
ggplot(Warden.sum.MDS.pts, aes(x=MDS1, y=MDS2)) + xlim(min(Warden.sum.MDS.pts$MDS1)*1.5, max(Warden.sum.MDS.pts$MDS1)*1.3) + ylim(min(Warden.sum.MDS.pts$MDS2)*1.3, max(Warden.sum.MDS.pts$MDS2)*1.3) + coord_fixed(ratio = 1) + geom_point(aes(size = BEdat.sum$Depth, colour=BEdat.sum$Depth)) + scale_size(range = c(9,20)) + geom_text(aes(label = Survey), cex=3, vjust=2, hjust=1.25) + theme(legend.position = "none") + theme(legend.title = element_blank()) + theme(legend.position = "top") + theme(legend.text=element_text(size=12)) + theme(plot.margin=unit(c(0,0,0,0),"mm")) + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank()) + theme(axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank()) + theme(legend.title = element_blank()) + theme(legend.position = "none")

#spring
ggplot(Warden.spr.MDS.pts, aes(x=MDS1, y=MDS2)) + xlim(min(Warden.spr.MDS.pts$MDS1)*1.5, max(Warden.spr.MDS.pts$MDS1)*1.3) + ylim(min(Warden.spr.MDS.pts$MDS2)*1.3, max(Warden.spr.MDS.pts$MDS2)*1.3) + coord_fixed(ratio = 1) + geom_point(aes(size = BEdat.spr$Depth, colour=BEdat.spr$Depth)) + scale_size(range = c(9,20)) + geom_text(aes(label = Survey), cex=3, vjust=2, hjust=1.25) + theme(legend.position = "none") + theme(legend.title = element_blank()) + theme(legend.position = "top") + theme(legend.text=element_text(size=12)) + theme(plot.margin=unit(c(0,0,0,0),"mm")) + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank()) + theme(axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank()) + theme(legend.title = element_blank()) + theme(legend.position = "none")
```

```{r}
#3D plot - need to add labels
cols <- c("red", "blue", "green")
with(Warden.spr.MDS.pts, 
     scatterplot3d(MDS1,
                   MDS2, 
                   MDS3,
                   xlab = "MDS1",
                   ylab = "MDS2",
                   zlab = "MDS3",
                   pch = 16, cex.symbols=3, color = cols[as.numeric(Warden.spr.MDS.pts$Cluster)], type="h"))

legend("right", legend = levels(Warden.spr.MDS.pts$Cluster),
      col =  c("red", "blue", "green"), pch = 16)
```

###Bioenv analyses of environment - community relationships

```{r}
#Create euclidean distance matrices for datasets to be used to partial bioenv analysis
Pipeline.spr.m <-vegdist(Pipeline.spr$Pipeline_days, method="euclidean")
Pipeline.sum.m <- vegdist(Pipeline.sum$Pipeline_days, method ="euclidean")
Surv.spr.m <- vegdist(Surv.Pipe.spr$Days, method="euclidean")
Surv.sum.m <- vegdist(Surv.Pipe.sum$Days, method="euclidean")
Surv.Pipe.spr.m <- vegdist(Surv.Pipe.spr, method="euclidean")
Surv.Pipe.sum.m <- vegdist(Surv.Pipe.sum, method="euclidean")
```

```{r}
#Test for effect of Pipeline operation

#spring
Pipeline.sp <- bioenv(Warden.spr.m ~ Pipeline_days, Pipeline.spr, method = "pearson", index = "bray", ) #bioenv to testfor effect of pipeline operation days
Pipeline.sp
Pipeline.sp.be <- bioenvdist(Pipeline.sp, which = "best") #extract euclidean matrix based on Pipeline_days
mantel(vegdist(Warden.spr.m, method = "bray"), Pipeline.spr.m, method="pearson", permutations=999) 

#summer
Pipeline.su <- bioenv(Warden.sum.m ~ Pipeline_days, Pipeline.sum, method = "pearson", index = "bray", ) #bioenv to testfor effect of pipeline operation days
Pipeline.su
Pipeline.su.be <- bioenvdist(Pipeline.su, which = "best") #extract euclidean matrix based on Pipeline_days
mantel(vegdist(Warden.sum.m, method = "bray"), Pipeline.sum.m, method="pearson", permutations=999) 
```

```{r}
#Test for effect of survey timing

#spring
SurvTime.sp <- bioenv(Warden.spr.m ~ Surv.Pipe.spr[, "Days"], method = "pearson", index = "bray", ) #bioenv to test for effect of pipeline operation days
SurvTime.sp
SurvTime.sp.be <- bioenvdist(SurvTime.sp, which = "best") #extract euclidean matrix based on Pipeline_days
mantel(vegdist(Warden.spr.m, method = "bray"), SurvTime.sp.be, method="pearson", permutations=999) 
#summer
SurvTime.su <- bioenv(Warden.sum.m ~ Surv.Pipe.sum[, "Days"], method = "pearson", index = "bray", ) #bioenv to test for effect of pipeline operation days
SurvTime.su
SurvTime.su.be <- bioenvdist(SurvTime.su, which = "best") #extract euclidean matrix based on Pipeline_days
mantel(vegdist(Warden.sum.m, method = "bray"), SurvTime.su.be, method="pearson", permutations=999)  
```

```{r}
#Bio-env analysis to determine influence of pipeline operation, depth and rainfall on waterbrd communities on the Warden wetlands.
#Uses pearson correlation because env vars without major outliers and not too far off normal in qqnorm plots.

#SPRING
#step-wise analysis with pipeline variable partialled out.
Warden.spr.be1 <- bioenv(Warden.spr.m, BEdat.spr2, method = "pearson", index = "bray", metric="euclidean", partial = BEdat.spr2$Pipeline_days)
Warden.spr.be1
#mantel tests
Warden.spr.md <- vegdist(Warden.spr.m, method = "bray") #calculate Warden spring waterbird bray-curtis dissimilarity index
BEdat.spr.md <-bioenvdist(Warden.spr.be1, which="best") #extract best subset of env vars
mantel(Warden.spr.md, BEdat.spr.md, method="pearson", permutations=999) #mantel test to determine permutational significance

#step-wise analysis with pipeline variable allowed in (use dataset BEdat.spr2)
Warden.spr.be2 <- bioenv(Warden.spr.m, BEdat.spr2, method = "pearson", index = "bray", metric="euclidean")
Warden.spr.be2
#mantel tests
BEdat.spr.md2 <-bioenvdist(Warden.spr.be2, which="best")
mantel(Warden.spr.md, BEdat.spr.md2, method="pearson", permutations=999) #mantel test to determine permutational significance

#SUMMER
Warden.sum.be <- bioenv(Warden.sum.m, BEdat.sum2, method = "pearson", index = "bray", metric="euclidean", partial = BEdat.sum2$Pipeline_days)
Warden.sum.be
Warden.sum.md <- vegdist(Warden.sum.m, method = "bray") #calculate Warden spring waterbird bray-curtis dissimilarity index
BEdat.sum.md <-bioenvdist(Warden.sum.be, which="best")
mantel(Warden.sum.md, BEdat.sum.md, method="pearson", permutations=999) #mantel test to determine permutational significance

#step-wise analysis with pipeline variable allowed in (use dataset BEdat.spr2)
Warden.sum.be2 <- bioenv(Warden.sum.m, BEdat.sum2, method = "pearson", index = "bray", metric="euclidean")
Warden.sum.be2
#mantel tests
BEdat.sum.md2 <-bioenvdist(Warden.sum.be2, which="best")
mantel(Warden.sum.md, BEdat.sum.md2, method="pearson", permutations=999) #mantel test to determine permutational significance
```

```{r}
#Bio-env analysis to determine which species best match patterns in overall community ordination

#spring
Warden.spr.msq <- Warden.spr.m #sqrt dataset since bv.step (as opposed to bvstep) does not do this, but needs to be done for consistency.
Warden.spr.bio <- bv.step(Warden.spr.msq, Warden.spr.msq, scale.fix=FALSE, scale.var=FALSE, fix.dist.method = "bray", var.dist.method = "bray", max.rho=0.95, min.delta.rho=0.01, output.best=10, num.restarts = 100)
Warden.spr.bio
#note: warnings are not important, see http://menugget.blogspot.com/2011/06/clarke-and-ainsworths-bioenv-and-bvstep.html
spring.species <- c("Australian.Shelduck","Banded.Stilt","Grey.Teal","Black.Swan")
Warden.spr4 <- Warden.spr.m[, spring.species] # create new survey x specie matrix with the 4 species from the bv.step analysis
write.csv(Warden.spr4, "./outputs/Warden 4 species.csv")
Warden.spr4.m <- vegdist(Warden.spr4, method= "bray") #create dissimilarity matrix for just 8 species, for use in mantel tests
Warden.spr.md <- vegdist(Warden.spr.m, method = "bray") #calculate Warden spring 
mantel(Warden.spr.md, Warden.spr4.m, method="pearson", permutations=999) #mantel test to determine permutational significance
Warden.sprsp.m <- Warden.spr.msq[, spring.species] #extract just the 4 species for spring

#summer
Warden.sum.msq <- Warden.sum.m #sqrt dataset since bv.step (as opposed to bvstep) does not do this, but needs to be done for consistency.
Warden.sum.bio <- bv.step(Warden.sum.msq, Warden.sum.msq, scale.fix=FALSE, scale.var=FALSE, fix.dist.method = "bray", var.dist.method = "bray", max.rho=0.95, min.delta.rho=0.01, output.best=10, num.restarts = 200)
Warden.sum.bio
#note: warnings are not important, see http://menugget.blogspot.com/2011/06/clarke-and-ainsworths-bioenv-and-bvstep.html
summer.species <- c("Banded.Stilt","Black.Swan","Pacific.Black.Duck","Red.necked.Avocet","Australian.Shelduck","Grey.Teal","Eurasian.Coot")
Warden.sum7 <- Warden.sum.m[, summer.species] # create new survey x specie matrix with the 8 species from the bv.step analysis
write.csv(Warden.sum7, "./outputs/Warden 7 species.csv")
Warden.sum7.m <- vegdist(Warden.sum7, method= "bray") #create dissimilarity matrix for just 8 species, for use in mantel tests
Warden.sum.md <- vegdist(Warden.sum.m, method = "bray") #calculate Warden suming 
mantel(Warden.sum.md, Warden.sum7.m, method="pearson", permutations=999) #mantel test to determine permutational significance
Warden.sumsp.m <- Warden.sum.msq[, summer.species] #extract just the 8 species for spring
```

```{r}
#db-RDA analyses including extended plotting - not used in 2023 report

#spring
#test individual variables
# mod1 <- capscale(Warden.spr.m ~ Depth, BEdat.spr.st2, dist="bray") #test individual variables (use BEdat.spr2 to include Pipeline_days
# mod1
# anova(mod1) #signif of individual variable

#stepwise model procedure with 'pipeline' data partialled out

#spring
# mod2 <- capscale(Warden.spr.m ~ Depth + CDM3MO_ESPER + CDM6MO_ESPER + CDM12MO_ESPER + CDM3MO_EAERO + CDM6MO_EAERO + CDM12MO_EAERO + CDM3MO_MYRUP + CDM6MO_MYRUP + CDM12MO_MYRUP + Pipeline_days, BEdat.spr.st2, dist="bray") #full model
# mod0 <- capscale(Warden.spr.m ~ 1, BEdat.spr.st2, dist="bray") #Null model
# ind <- ordistep(mod0, scope = formula(mod2), perm.max = 999) #stepwise model build from all
# anova(ind) #signif of stepwise model
# mod3 <- capscale(Warden.spr.m ~ CDM12MO_EAERO, BEdat.spr.st2, dist ="bray") #model selected by ordistep
# mod3 #view results of stepwise model
# anova(mod3) #signif or stepwise model
#build db-RDA plot from components
#plot(mod3, type = "n", choices = c(1, 2))
#points(mod3, display = "sites", pch=21, bg = "grey", cex=Warden.sprsp.m$Straw.necked.Ibis^2/50) #scale #sites by abundances of the 8 species
# text(mod3, display = "sites", cex = 0.7)
# points(mod3, display = "bp", cex=2)
# text(mod3, display = "bp", cex=0.7, col="blue")

#summer
# mod1 <- capscale(Warden.sum.m ~ CDM12MO_MYRUP, BEdat.sum.st, dist="bray") #test individual variables
# mod1
# anova(mod1) #signif of individual variable
#stepwise model build
# mod2 <- capscale(Warden.sum.m ~ ., BEdat.sum.st, dist="bray") #full model
# mod0 <- capscale(Warden.sum.m ~ 1, BEdat.sum.st, dist="bray") #Null model
# ind <- ordistep(mod0, scope = formula(mod2), perm.max = 999) #stepwise model build from all
# anova(ind) #signif of stepwise model
# mod3 <- capscale(Warden.sum.m ~ CDM6MO_MYRUP, BEdat.sum.st, dist ="bray")
# mod3
```

###Analyses with or without Lake warden

```{r}
#Create a Warden matrix without Lake Warden data
# Warden.spr.NoWa <- Warden.spr[-grep("WRP013", Warden.spr$SiteCode), ] #remove records for Lake Warden
# Warden.spr.NoWa.agg<- aggregate(data=Warden.spr.NoWa, Count ~ CommonName + Survey, FUN="sum")
# Warden.spr.NoWa.m <- melt(Warden.spr.NoWa.agg)
# Warden.spr.NoWa.m <- dcast(Warden.spr.NoWa.m, Survey ~ CommonName, fill="0")
# rownames(Warden.spr.NoWa.m) <- Warden.spr.NoWa.m[,1]
# Warden.spr.NoWa.m[,1] <- NULL
# write.csv(Warden.spr.NoWa.m, "./outputs/Warden_spr_NoWa_m.csv")
# Warden.spr.NoWa.m <- read.csv("./outputs/Warden_spr_NoWa_m.csv", row.names=1)
```

```{r}
#Create a warden matrix of just Lake Warden
# Warden.spr.Wa <- Warden.spr[Warden.spr$SiteCode == "WRP013", ] #include only records for Lake Warden
# Warden.spr.Wa.agg<- aggregate(data=Warden.spr.Wa, Count ~ CommonName + Survey, FUN="sum")
# Warden.spr.Wa.m <- melt(Warden.spr.Wa.agg)
# Warden.spr.Wa.m <- dcast(Warden.spr.Wa.m, Survey ~ CommonName, fill="0")
# rownames(Warden.spr.Wa.m) <- Warden.spr.Wa.m[,1]
# Warden.spr.Wa.m[,1] <- NULL
# write.csv(Warden.spr.Wa.m, "./outputs/Warden_spr_NoWa_m.csv")
# Warden.spr.Wa.m <- read.csv("./outputs/Warden_spr_NoWa_m.csv", row.names=1)
# Warden.spr.Wa.md <- vegdist(Warden.spr.Wa.m, method = "bray")
# write.csv(as.matrix(Warden.spr.Wa.md), file = "./outputs/Warden_spr_Wa_md.csv")
```

```{r}
#Bioenv without Lake Warden - just Pipeline days
# Warden.spr.NoWa.be <- bioenv(Warden.spr.NoWa.m, Pipeline.spr, method = "pearson", index = "bray", metric="euclidean")
# Warden.spr.NoWa.be
# Warden.spr.NoWa.md <- vegdist(Warden.spr.NoWa.m, method = "bray") #calculate Warden spring waterbird bray-curtis dissimilarity index
# Pipeline.NoWa.be.m <-bioenvdist(Warden.spr.NoWa.be, which="best")
# mantel(Warden.spr.NoWa.md, Pipeline.NoWa.be.m, method="pearson", permutations=999) #mantel test to determine permutational significance
```

```{r}
#db-RDA without lake Warden
# mod2 <- capscale(Warden.spr.NoWa.m ~ ., BEdat.spr2, dist="bray") #full model
# mod0 <- capscale(Warden.spr.NoWa.m ~ 1, BEdat.spr2, dist="bray") #Null model
# ind <- ordistep(mod0, scope = formula(mod2), perm.max = 999) #stepwise model build from all
# anova(ind) #signif of stepwise model
# mod3 <- capscale(Warden.spr.NoWa.m ~ Pipeline_days, BEdat.spr2, dist ="bray") #model selected by ordistep
# anova(mod3) #signif or stepwise model
# mod3 #stepwise model
```

###Create env dataset with just those vars from the rda and bio-env analyses

```{r}
# env.restricted.spr <- c("CDM12MO_ESPER", "CDM12MO_EAERO", "Depth", "Pipeline_days")
# #non-standardised
# BEdat.spr.rest <- BEdat.spr2[, env.restricted.spr]
# #standardised
# BEdat.spr.st2.rest <- BEdat.spr.st2[, env.restricted.spr]
```

####env fit to add waterbird and environmental vectors to unconstrained ordination

```{r}
#uses Warden.sprsp (from the bio-bio bv.step analysis above) and BEdat.spr.rest (from code above)
# fit.spr.birds <- envfit(Warden.spr.MDS, Warden.sprsp.m, permutations = 999, choices=c(1,2)) #fit these species as vectors in unconstrained ordination
# Warden.arrows.spr.birds <-as.data.frame(fit.spr.birds$vectors$arrows*sqrt(fit.spr.birds$vectors$r)) #extract vector coordinates
# Warden.arrows.spr.birds$Species <- row.names(Warden.arrows.spr.birds) #add species names to vectors
# #restricted env vars envfit
# plot(Warden.spr.MDS, type = "n", xlim=c(-0.4, 0.5), ylim=c(-0.4, 0.3))
# points(Warden.spr.MDS, display = "sites", bg = "grey", pch=21, cex = Warden.spr7$Australian.Shelduck/500)
# text(Warden.spr.MDS, display = "sites", cex = 0.7)
# plot(fit.spr.birds)
# 
# fit.spr.env <- envfit(Warden.spr.MDS, BEdat.spr.st2.rest, permutations = 999) #fit env vars as vectors in unconstrained ordination
# plot(Warden.spr.MDS, type = "n", xlim=c(-0.4, 0.5), ylim=c(-0.4, 0.3))
# points(Warden.spr.MDS, display = "sites", bg = "grey", pch=21, cex=BEdat.spr.rest$CDM12MO_ESPER/15)
# text(Warden.spr.MDS, display = "sites", cex = 0.7)
# plot(fit.spr.env)
```

```{r}
# ggplot(Warden.spr.MDS.pts, aes(x=MDS1, y=MDS2)) + xlim(-0.8, 0.6) + ylim(-0.6, 0.6) + coord_fixed(ratio = 1) + geom_point(aes(size = 2)) + geom_text(aes(label = Survey), colour="blue", cex=3, vjust=2, hjust=1.25) + theme(legend.position = "none") + scale_x_reverse(limits=c(0.6, -0.8)) + geom_segment(data=Warden.arrows.spr.birds,aes(x=0,xend=NMDS1,y=0,yend=NMDS2), arrow = arrow(length = unit(0.5, "cm")),colour="grey",inherit_aes=FALSE) + geom_text(data=Warden.arrows.spr.birds,aes(x=NMDS1,y=NMDS2,label=Species),size=3)
# #see https://stackoverflow.com/questions/14711470/plotting-envfit-vectors-vegan-package-in-ggplot2 for adding vectors to ggplot ordination
```

###Stacked abundance column plots for Warden system waterbirds

```{r}
Warden.stack <- input.data[input.data$System == "Warden", ]
Warden.stack$Group <- Taxonomy[match(Warden.stack$CommonName, Taxonomy$CommonName), 3]

write.csv(Warden.stack, "./outputs/Warden.stack.csv")
```

```{r}
# Aggregate data by taxonomic group and survey, with survey and season variables for plotting
# plus add dummy dates for years not surveyed

Warden.stack.agg <- aggregate(data=Warden.stack, Count ~ Group + Survey + Season, FUN="sum") #aggregate count data by species and survey
#create dummy data for missing survey years for spring and summer
md.Group <- rep("Grebes", times = 7)
md.Survey <- c("Nov-2015","Nov-2016","Nov-2017","Nov-2019","Feb-2016","Feb-2017","Feb-2018")
md.Season <- c(rep("spring", times = 4), rep("summer", times = 3))
md.Count <- rep(0, times = 7)
Missing.dates <- data.frame(md.Group, md.Survey, md.Season, md.Count)
colnames(Missing.dates) <- c("Group","Survey","Season","Count")
Warden.stack.agg <- rbind(Warden.stack.agg, Missing.dates)
Warden.stack.agg$SurvOrd <- as.character(Warden.stack.agg$Survey)
Warden.stack.agg$SurvOrd <- as.numeric(str_replace_all(Warden.stack.agg$SurvOrd, c("Feb-2008" = "1", "Feb-2010" = "2", "Feb-2011" = "3", "Feb-2012" = "4", "Feb-2013" = "5", "Feb-2014" = "6", "Feb-2015" = "7", "Feb-2016" = "8", "Feb-2017" = "9", "Feb-2018" = "10", "Feb-2019" = "11", "Feb-2021" = "12", "Oct-2006" = "1", "Oct-2007" = "2", "Nov-2008" = "3", "Nov-2009" = "4", "Nov-2010" = "5", "Dec-2011" = "6", "Oct-2012" = "7", "Nov-2013"= "8", "Nov-2014" = "9", "Nov-2015" = "10", "Nov-2016" = "11", "Nov-2017" = "12", "Nov-2018" = "13", "Nov-2019" = "14", "Nov-2020" = "15")))
```

```{r}
# stacked column plots for Warden by season

#spring
Warden.stack.spr <- Warden.stack.agg[Warden.stack.agg$Season=="spring", ] #cut down to just spring data
Warden.stack.spr <- Warden.stack.spr[ order(Warden.stack.spr$SurvOrd), ]
ggplot(Warden.stack.spr, aes(x=reorder(Survey, SurvOrd), y=Count, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,30000, by=5000), limits=c(0,30000)) + labs(x="Survey", y="Abundance") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(size = 20, margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(size = 20, margin = margin(t = 20, r = 0, b = 0, l = 0))) + theme(axis.text.x = element_text(size=12)) + theme(axis.text.y = element_text(size=15)) + scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#A2B5CD","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A"))

#summer
Warden.stack.sum <- Warden.stack.agg[Warden.stack.agg$Season=="summer", ] #cut down to just summer data
Warden.stack.sum <- Warden.stack.sum[ order(Warden.stack.sum$SurvOrd), ]
ggplot(Warden.stack.sum, aes(x=reorder(Survey, SurvOrd), y=Count, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,30000, by=5000), limits=c(0,30000)) + labs(x="Survey", y="Abundance") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(size = 20, margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(size = 20, margin = margin(t = 20, r = 0, b = 0, l = 0))) + theme(axis.text.x = element_text(size=12)) + theme(axis.text.y = element_text(size=15)) + scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#A2B5CD","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A")) #uses Date to reorder survey on x axis
```

```{r}
#Create group x survey matrix from stack.agg files
Warden.group.spr <- Warden.stack.spr[, c("Group", "Survey", "Count")] #remove unwanted columns
Warden.group.spr <- pivot_wider(Warden.group.spr, names_from = "Survey", values_from = "Count") #create matrix by widening table
Warden.group.spr <- as.data.frame(Warden.group.spr)
write.csv(Warden.group.spr, "./outputs/Warden spring by group.csv")

Warden.group.sum <- Warden.stack.sum[, c("Group", "Survey", "Count")] #remove unwanted columns
Warden.group.sum <- pivot_wider(Warden.group.sum, names_from = "Survey", values_from = "Count") #create matrix by widening table
Warden.group.sum <- as.data.frame(Warden.group.sum)
write.csv(Warden.group.sum, "./outputs/Warden summer by group.csv")
```

###Stacked column plots for species richness at Warden

```{r}
Warden.stack.rich <- input.data.2[input.data.2$System == "Warden", ]
Warden.stack.rich$Group <- Taxonomy[match(Warden.stack.rich$CommonName, Taxonomy$CommonName), 3]
```

```{r}
#create matrix for examining data
Warden_matrix <- acast(Warden.stack.rich, Group+CommonName ~ Survey, value.var="Count", fun.aggregate = sum) #sums counts for each species and survey
write.csv(Warden_matrix, "./outputs/Warden_matrix.csv")
```

```{r}
#Aggregate counts by common name, then count number of species within groups
Warden.stack.rich <- aggregate(data=Warden.stack.rich, Count ~ CommonName + Group + Survey + Season, FUN="sum") #aggregate count data by species and survey
Warden.stack.rich <- Warden.stack.rich[, c("Survey","Group","Season")] #restrict data to 3 columns
Warden.stack.rich <- count(Warden.stack.rich, c("Group","Survey","Season")) #count no. species
#create dummy years
md.Group <- rep("Grebes", times = 7)
md.Survey <- c("Nov-2015","Nov-2016","Nov-2017","Nov-2019","Feb-2016","Feb-2017","Feb-2018")
md.Season <- c(rep("spring", times = 4), rep("summer", times = 3))
md.freq <- rep(0, times = 7)
Missing.dates <- data.frame(md.Group, md.Survey, md.Season, md.freq)
colnames(Missing.dates) <- c("Group","Survey","Season","freq")
Warden.stack.rich <- rbind(Warden.stack.rich, Missing.dates)
Warden.stack.rich$SurvOrd <- as.character(Warden.stack.rich$Survey)
Warden.stack.rich$SurvOrd <- as.numeric(str_replace_all(Warden.stack.rich$SurvOrd, c("Feb-2008" = "1", "Feb-2010" = "2", "Feb-2011" = "3", "Feb-2012" = "4", "Feb-2013" = "5", "Feb-2014" = "6", "Feb-2015" = "7", "Feb-2016" = "8", "Feb-2017" = "9", "Feb-2018" = "10", "Feb-2019" = "11", "Oct-2006" = "1", "Oct-2007" = "2", "Nov-2008" = "3", "Nov-2009" = "4", "Nov-2010" = "5", "Dec-2011" = "6", "Oct-2012" = "7", "Nov-2013"= "8", "Nov-2014" = "9", "Nov-2015" = "10", "Nov-2016" = "11", "Nov-2017" = "12", "Nov-2018" = "13", "Nov-2019" = "14", "Nov-2020" = "15")))
```

###

```{r}
# stacked richness column plots for Warden by season

#spring
Warden.stack.rich.spr <- Warden.stack.rich[Warden.stack.rich$Season=="spring", ]
#cut down to just spring data
Warden.stack.rich.spr <- Warden.stack.rich.spr[order(Warden.stack.rich.spr$SurvOrd), ]

ggplot(Warden.stack.rich.spr, aes(x=reorder(Survey, SurvOrd), y=freq, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,50, by=10), limits=c(0,50)) + labs(x="Survey", y="Number of species") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(size=20, margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(size=20, margin = margin(t = 20, r = 0, b = 0, l = 0))) + theme(axis.text.x = element_text(size=12)) + theme(axis.text.y = element_text(size=15)) + scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#A2B5CD","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A"))

#summer
Warden.stack.rich.sum <- Warden.stack.rich[Warden.stack.rich$Season=="summer", ] #cut down to just summer data
Warden.stack.rich.sum <- Warden.stack.rich.sum[ order(Warden.stack.rich.sum$SurvOrd), ]

ggplot(Warden.stack.rich.sum, aes(x=reorder(Survey, SurvOrd), y=freq, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,50, by=10), limits=c(0,50)) + labs(x="Survey", y="Number of species") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(size=20, margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(size = 20, margin = margin(t = 20, r = 0, b = 0, l = 0))) + theme(axis.text.x = element_text(size=12)) + theme(axis.text.y = element_text(size=15))+ scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#A2B5CD","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A"))
```

```{r}
#Create richness x survey matrix for output

#spring
Warden.grouprich.spr <- Warden.stack.rich.spr[, c("Group", "Survey", "freq")] #remove unwanted columns
Warden.grouprich.spr <- pivot_wider(Warden.grouprich.spr, names_from = "Survey", values_from = "freq") #create matrix by widening table
Warden.grouprichspr <- as.data.frame(Warden.grouprich.spr)
write.csv(Warden.grouprich.spr, "./outputs/Warden rich spring by group.csv")

#summer
Warden.group.sum <- Warden.stack.sum[, c("Group", "Survey", "Count")] #remove unwanted columns
Warden.group.sum <- pivot_wider(Warden.group.sum, names_from = "Survey", values_from = "Count") #create matrix by widening table
Warden.group.sum <- as.data.frame(Warden.group.sum)
write.csv(Warden.group.sum, "./outputs/Warden summer by group.csv")
```

###Calculate total abundances per survey by season

```{r}
#spring
Warden.spr$year <- lubridate::year(Warden.spr$Date)
Warden.spr.yearsums <- aggregate(data=Warden.spr, Count ~ year + year, FUN="sum")
write.csv(Warden.spr.yearsums, "./outputs/warden_spr_yearsums.csv")

#summer
Warden.sum$year <- lubridate::year(Warden.sum$Date)
Warden.sum.yearsums <- aggregate(data=Warden.sum, Count ~ year + year, FUN="sum")
write.csv(Warden.sum.yearsums, "./outputs/warden_sum_yearsums.csv")
```

### Import data for species x species analysis

```{r}
Species <- input.data.2
  Species.sum <- Species[Species$Season == "summer", ] #summer only data
  Species.spr <- Species[Species$Season == "spring", ] #spring only data
```

#### extract data for particular species

```{r}
sp.id <- "Chestnut Teal"
sp.selected <- Species[Species$CommonName == sp.id, ]
sp.selected <- sp.selected[order(sp.selected$Date), ]
write.csv(sp.selected, file = sp.id)
```

#### Abundance plots for key Warden species
```{r}
#SPRING
Warden.spr.splots <- as_tibble(Warden.spr[, c(7,9,10)])
#select species
Warden.spr.splots <- Warden.spr.splots %>% filter(CommonName %in% c("Australian Shelduck","Hoary-headed Grebe","Yellow-billed Spoonbill","Grey Teal","Australian White Ibis","Black Swan","Hooded Plover","Red-necked Avocet","Red-necked Stint","Sharp-tailed Sandpiper","Banded Stilt"))
#aggregate data within survey
Warden.spr.splots.agg <- aggregate(data=Warden.spr.splots, Count ~ CommonName + Survey, FUN="sum")

#create dummy data for non surveyed dates
md.Group <- rep("Australian Shelduck", times = 5)
md.Survey <- c("Nov-2015","Nov-2016","Nov-2017","Nov-2019","Nov-2021")
md.Count <- rep(0, times = 5)
Missing.dates <- data.frame(md.Group, md.Survey, md.Count)
colnames(Missing.dates) <- c("CommonName","Survey","Count")
Warden.spr.splots.agg <- rbind(Warden.spr.splots.agg, Missing.dates)

#convert CommonName and Survey to factors with defined order
Warden.spr.splots.agg$CommonName <- factor(Warden.spr.splots.agg$CommonName, levels = c("Australian Shelduck","Hoary-headed Grebe","Yellow-billed Spoonbill","Grey Teal","Red-necked Avocet","Australian White Ibis","Black Swan","Hooded Plover","Red-necked Stint","Sharp-tailed Sandpiper","Banded Stilt"))
Warden.spr.splots.agg$Survey <- factor(Warden.spr.splots.agg$Survey, levels = c("Oct-2006", "Oct-2007", "Nov-2008", "Nov-2009", "Nov-2010", "Dec-2011", "Oct-2012", "Nov-2013", "Nov-2014", "Nov-2015", "Nov-2016", "Nov-2017", "Nov-2018", "Nov-2019", "Nov-2020", "Nov-2021","Nov-2022"))
#plot data
ggplot(Warden.spr.splots.agg, aes(Survey, Count)) + geom_col() + facet_grid(CommonName~., scales="free_y") + theme(axis.text.x = element_text(angle = 90, size=12, hjust=0.5, vjust=0.5)) + theme(axis.text.y = element_text(size=12)) + theme(axis.title=element_text(size=14)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

#SUMMER
Warden.sum.splots <- as_tibble(Warden.sum)
#select species
Warden.sum.splots <- Warden.sum.splots %>% filter(CommonName %in% c("Darter", "Common Greenshank", "Hoary-headed Grebe", "Eurasian Coot", "Silver Gull", "Red-capped Plover", "Little Black Cormorant", "Hooded Plover"))
#aggregate data within survey
Warden.sum.splots.agg <- aggregate(data=Warden.sum.splots, Count ~ CommonName + Survey, FUN="sum")

#create dummy data for non surveyed dates
md.Group <- rep("Common Greenshank", times = 5)
md.Survey <- c("Feb-2016","Feb-2017","Feb-2018","Feb-2020","Feb-2022")
md.Count <- rep(0, times = 5)
Missing.dates <- data.frame(md.Group, md.Survey, md.Count)
colnames(Missing.dates) <- c("CommonName","Survey","Count")
Warden.sum.splots.agg <- rbind(Warden.sum.splots.agg, Missing.dates)

#convert CommonName and Survey to factors with defined order
Warden.sum.splots.agg$CommonName <- factor(Warden.spr.splots.agg$CommonName, levels = c("Darter", "Common Greenshank", "Hoary-headed Grebe", "Eurasian Coot", "Silver Gull", "Red-capped Plover", "Little Black Cormorant", "Hooded Plover"))
Warden.sum.splots.agg$Survey <- factor(Warden.sum.splots.agg$Survey, levels = c("Feb-2008", "Feb-2010", "Feb-2011", "Feb-2012", "Feb-2013", "Feb-2014", "Feb-2015", "Feb-2016", "Feb-2017", "Feb-2018", "Feb-2019", "Feb-2020", "Feb-2021", "Feb-2022", "Feb-2023"))
#plot data
ggplot(Warden.sum.splots.agg, aes(Survey, Count)) + geom_col() + facet_grid(CommonName~., scales="free_y") + theme(axis.text.x = element_text(angle = 90, size=12, hjust=0.5, vjust=0.5)) + theme(axis.text.y = element_text(size=12)) + theme(axis.title=element_text(size=14)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

Warden.spr.splots <- as_tibble(Warden.spr)
Warden.spr.splots <- Warden.spr.splots %>% filter(CommonName %in% c("Australian Shelduck","Hoary-headed Grebe","Yellow-billed Spoonbill","Grey Teal","Australian White Ibis","Black Swan","Hooded Plover","Red=-necked Avocet","Red-necked Stint","Sharp-tailed Sandpiper","Banded Stilt"))
Warden.spr.splots$SurvOrd <- Warden.spr.splots$Survey
Warden.spr.splots$SurvOrd <- as.numeric(str_replace_all(Warden.spr.splots$SurvOrd, c("Oct-2006" = "1", "Oct-2007" = "2", "Nov-2008" = "3", "Nov-2009" = "4", "Nov-2010" = "5", "Dec-2011" = "6", "Oct-2012" = "7", "Nov-2013"= "8", "Nov-2014" = "9", "Nov-2015" = "10", "Nov-2016" = "11", "Nov-2017" = "12", "Nov-2018" = "13", "Nov-2019" = "14", "Nov-2020" = "15", "Nov-2022" = "16")))
Warden.spr.splots
```


##GORE SYSTEM ANALYSIS ONLY

###Totals of species abundances x year

```{r}
#spring
Gore_SxY.spr <- input.data[input.data$System == "Gore", ]
Gore_SxY.spr <- Gore_SxY.spr[Gore_SxY.spr$Season == "spring", ]
Gore_SxY.spr$Year <- year(Gore_SxY.spr$Date)
Gore_SxY.spr <- as.matrix(xtabs(Gore_SxY.spr$Count ~ Gore_SxY.spr$CommonName + Gore_SxY.spr$Year))
write.csv(Gore_SxY.spr, "./outputs/Gore_SxY.spr.csv")

#summer
Gore_SxY.sum <- input.data[input.data$System == "Gore", ]
Gore_SxY.sum <- Gore_SxY.sum[Gore_SxY.sum$Season == "summer", ]
Gore_SxY.sum$Year <- year(Gore_SxY.sum$Date)
Gore_SxY.sum <- as.matrix(xtabs(Gore_SxY.sum$Count ~ Gore_SxY.sum$CommonName + Gore_SxY.sum$Year))
write.csv(Gore_SxY.sum, "./outputs/Gore_SxY.sum.csv")
```

###Ordinations and associated analyses

```{r}
#Input waterbird data and split into spring and summer datasets, including creating a survey variable
Gore <- input.data.2[input.data.2$System == "Gore", ]
Gore.sum <- Gore[Gore$Season == "summer", ] #summer only data
Gore.sum$Group <- Taxonomy[match(Gore.sum$CommonName, Taxonomy$CommonName), 3]
Gore.spr <- Gore[Gore$Season == "spring", ] #spring only data
Gore.spr$Group <- Taxonomy[match(Gore.spr$CommonName, Taxonomy$CommonName), 3]
```

```{r}
#Create a matrix for checking counts - this not used in analysis
Gore_matrix <- as.data.frame(acast(Gore, CommonName ~ Survey, value.var="Count", fun.aggregate = sum)) #sums counts for each species and survey
Gore_matrix$Group <- Taxonomy[match(row.names(Gore_matrix), Taxonomy$CommonName), 3]
write.csv(Gore_matrix, "./outputs/Gore_matrix.csv")
```

```{r}
#Aggregate count data by just common name and survey for creating season matrices
Gore.sum.agg <- aggregate(data=Gore.sum, Count ~ CommonName + Survey, FUN="sum") #aggregate count data by species and survey
Gore.spr.agg<- aggregate(data=Gore.spr, Count ~ CommonName + Survey, FUN="sum") #aggregate count data by species and survey
```

```{r}
#Aggregate by group and produce matrices of year x group for each season
Gore.sum.agg.gp <- aggregate(data=Gore.sum, Count ~ Group + Survey, FUN="sum") #aggregate count data by species and survey
Gore.sum.gp.m <- melt(Gore.sum.agg.gp)
Gore.sum.gp.m <- dcast(Gore.sum.gp.m, Survey ~ Group, fill="0")
rownames(Gore.sum.gp.m) <- Gore.sum.gp.m[,1]
Gore.sum.gp.m[,1] <- NULL
write.csv(Gore.sum.gp.m, "./outputs/Gore_sum_gp_m.csv")

Gore.spr.agg.gp<- aggregate(data=Gore.spr, Count ~ Group + Survey, FUN="sum") #aggregate count data by species and survey
Gore.spr.gp.m <- melt(Gore.spr.agg.gp)
Gore.spr.gp.m <- dcast(Gore.spr.gp.m, Survey ~ Group, fill="0")
rownames(Gore.spr.gp.m) <- Gore.spr.gp.m[,1]
Gore.spr.gp.m[,1] <- NULL
write.csv(Gore.spr.gp.m, "./outputs/Gore_spr_gp_m.csv")
```

```{r}
#Create waterbird matrices by season

#summer
Gore.sum.m <- melt(Gore.sum.agg)
Gore.sum.m <- dcast(Gore.sum.m, Survey ~ CommonName, fill="0")
rownames(Gore.sum.m) <- Gore.sum.m[,1]
Gore.sum.m[,1] <- NULL
write.csv(Gore.sum.m, "./outputs/Gore_sum_m.csv")
Gore.sum.m <- read.csv("./outputs/Gore_sum_m.csv", row.names=1)

#spring
Gore.spr.m <- melt(Gore.spr.agg)
Gore.spr.m <- dcast(Gore.spr.m, Survey ~ CommonName, fill="0")
rownames(Gore.spr.m) <- Gore.spr.m[,1]
Gore.spr.m[,1] <- NULL
write.csv(Gore.spr.m, "./outputs/Gore_spr_m.csv")
Gore.spr.m <- read.csv("./outputs/Gore_spr_m.csv", row.names=1)
```

```{r}
#2D MDS unconstrained ordinations with vegan plots of Gore surveys by each season based on sqrt counts or raw counts

#summer - sqrt abundance
Gore.sum.m.sqrt <- sqrt(Gore.sum.m)
Gore.sum.MDS.sqrt <- metaMDS(Gore.sum.m.sqrt, distance = "bray", k=2, autotransform = FALSE)
plot(Gore.sum.MDS.sqrt, display = "sites", cex=5, xlim=c(-0.7, 0.5))
points(Gore.sum.MDS.sqrt, display = "species", cex=2, col="red")
text(Gore.sum.MDS.sqrt, display = "sites", cex=1, col="blue")
text(Gore.sum.MDS.sqrt, display = "species", cex=1)
stressplot(Gore.sum.MDS.sqrt)

#summer - raw abundance - which does not work - produces degenerate ordination.
Gore.sum.MDS <- metaMDS(Gore.sum.m, distance = "bray", k=2, autotransform = FALSE)
plot(Gore.sum.MDS, display = "sites", cex=5, xlim=c(-0.7, 0.5))
points(Gore.sum.MDS, display = "species", cex=2, col="red")
text(Gore.sum.MDS, display = "sites", cex=1, col="blue")
text(Gore.sum.MDS, display = "species", cex=1)
stressplot(Gore.sum.MDS)

#spring - sqrt abundance
Gore.spr.m.sqrt <- sqrt(Gore.spr.m)
Gore.spr.MDS.sqrt <- metaMDS(Gore.spr.m.sqrt, distance = "bray", k=2, autotransform = FALSE) #use Gore.spr.m (raw abundances) or Gore.spr.m.sqrt (sqrt transformed abundances)
Gore.spr.spscores.sqrt <- scores(Gore.spr.MDS.sqrt, display=c("sites"))
plot(Gore.spr.MDS.sqrt)
text(Gore.spr.MDS.sqrt, display="sites", cex=0.8)
text(Gore.spr.MDS.sqrt, display="species", cex=0.8)
stressplot(Gore.spr.MDS.sqrt)

#spring - raw abundance
Gore.spr.MDS <- metaMDS(Gore.spr.m, distance = "bray", k=2, autotransform = FALSE) #use Gore.spr.m (raw abundances) or Gore.spr.m.sqrt (sqrt transformed abundances)
Gore.spr.spscores <- scores(Gore.spr.MDS, display=c("species"))
plot(Gore.spr.MDS)
text(Gore.spr.MDS, display="sites", cex=0.8)
text(Gore.spr.MDS, display="species", cex=0.8)
stressplot(Gore.spr.MDS)
```

```{r}
#Extract ordination point data for ggplots for metaMDS Note - need to ensure the right ordination has been run (above), i.e. sqrt or raw count data

#summer
Gore.sum.MDS.pts <- as.data.frame(Gore.sum.MDS$points) #extract coordinates from ordination
Gore.sum.MDS.pts$Label2 <- row.names(Gore.sum.MDS.pts) #add survey name from row names and call variable Label2 so that species names can be added later
Gore.sum.MDS.pts$Label2 <- as.yearmon(Gore.sum.MDS.pts$Label, "%b-%Y") #convert label to date format using package zoo
Gore.sum.MDS.pts <- Gore.sum.MDS.pts[order(as.Date(Gore.sum.MDS.pts$Label2, format="%b-%Y")),] #order by Survey date
Gore.sum.MDS.pts$Label <- as.character(Gore.sum.MDS.pts$Label2) #convert Survey to character name and create new variable 'Label'
Gore.sum.MDS.pts$Type <- "Survey" #add data type (survey here and species later)
Gore.sum.MDS.pts$Label2 <- NULL 
Gore.sum.MDS.spscores <- as.data.frame(scores(Gore.sum.MDS, display = "species")) #extract species scores for later restricting to bio-bio (bv.step) outcome

#spring - raw counts
Gore.spr.MDS.pts <- as.data.frame(Gore.spr.MDS$points) #extract coordinates from ordination
Gore.spr.MDS.pts$Label2 <- row.names(Gore.spr.MDS.pts) #add survey name from row names and call variable Label2 so that species names can be added later
Gore.spr.MDS.pts$Label2 <- as.yearmon(Gore.spr.MDS.pts$Label, "%b-%Y") #convert label to date format using package zoo
Gore.spr.MDS.pts <- Gore.spr.MDS.pts[order(as.Date(Gore.spr.MDS.pts$Label2, format="%b-%Y")),] #order by Survey date
Gore.spr.MDS.pts$Label <- as.character(Gore.spr.MDS.pts$Label2) #convert Survey to character name and create new variable 'Label'
Gore.spr.MDS.pts$Type <- "Survey" #add data type (survey here and species later)
Gore.spr.MDS.pts$Label2 <- NULL 
Gore.spr.MDS.spscores <- as.data.frame(scores(Gore.spr.MDS, display = "species")) #extract species scores for later restricting to bio-bio (bv.step) outcome

#spring - sqrt counts
Gore.spr.MDS.sqrt.pts <- as.data.frame(Gore.spr.MDS.sqrt$points) #extract coordinates from ordination
Gore.spr.MDS.sqrt.pts$Label2 <- row.names(Gore.spr.MDS.sqrt.pts) #add survey name from row names and call variable Label2 so that species names can be added later
Gore.spr.MDS.sqrt.pts$Label2 <- as.yearmon(Gore.spr.MDS.sqrt.pts$Label, "%b-%Y") #convert label to date format using package zoo
Gore.spr.MDS.sqrt.pts <- Gore.spr.MDS.sqrt.pts[order(as.Date(Gore.spr.MDS.sqrt.pts$Label2, format="%b-%Y")),] #order by Survey date
Gore.spr.MDS.sqrt.pts$Label <- as.character(Gore.spr.MDS.sqrt.pts$Label2) #convert Survey to character name and create new variable 'Label'
Gore.spr.MDS.sqrt.pts$Type <- "Survey" #add data type (survey here and species later)
Gore.spr.MDS.sqrt.pts$Label2 <- NULL 
Gore.spr.MDS.sqrt.spscores <- as.data.frame(scores(Gore.spr.MDS, display = "species")) #extract species scores for later restricting to bio-bio (bv.step) outcome

```

```{r}
#Ordination graphs of Gore system waterbird communities by survey with surveys undertaken in spring and summer

#summer raw count data
xmin <- min(Gore.sum.MDS.pts$MDS1)*1.3
xmax <- max(Gore.sum.MDS.pts$MDS1)*1.3
ymin <- min(Gore.sum.MDS.pts$MDS2)*1.3
ymax <- max(Gore.sum.MDS.pts$MDS2)*1.3
ggplot(Gore.sum.MDS.pts, aes(x=MDS1, y=MDS2)) + xlim(xmin, xmax) + ylim(ymin, ymax) + coord_fixed(ratio = 1) + geom_point(cex=8) + geom_text(aes(label = Label), cex=3, vjust=2, hjust=1.6) + theme(legend.position = "none")

#spring raw count data
Gore.spr.MDS.pts.2 <- Gore.spr.MDS.pts
Gore.spr.MDS.pts.2$Label <- gsub(' ', '-', Gore.spr.MDS.pts.2$Label) #in Survey replace space with dash
Gore.spr.MDS.pts.2$Label <- paste("01-", Gore.spr.MDS.pts.2$Label, sep = "") #add dummy day to Survey
Gore.spr.MDS.pts.2$Label <- as.Date(Gore.spr.MDS.pts.2$Label, format = "%d-%b-%Y") #change survey to date
Gore.spr.MDS.pts.2<- Gore.spr.MDS.pts.2[order(Gore.spr.MDS.pts.2$Label), ] #order by date
xmin <- min(Gore.spr.MDS.pts.2$MDS1)*1.3
xmax <- max(Gore.spr.MDS.pts.2$MDS1)*1.3
ymin <- min(Gore.spr.MDS.pts.2$MDS2)*1.3
ymax <- max(Gore.spr.MDS.pts.2$MDS2)*1.3
ggplot(Gore.spr.MDS.pts, aes(x=MDS1, y=MDS2)) + xlim(xmin, xmax) + ylim(ymin, ymax) + coord_fixed(ratio = 1) + geom_point(cex=8) + geom_text(aes(label = Label), cex=3, vjust=2, hjust=1.3) + theme(legend.position = "none")

#spring sqrt count data
Gore.spr.MDS.sqrt.pts.2 <- Gore.spr.MDS.sqrt.pts
Gore.spr.MDS.sqrt.pts.2$Label <- gsub(' ', '-', Gore.spr.MDS.sqrt.pts.2$Label) #in Survey replace space with dash
Gore.spr.MDS.sqrt.pts.2$Label <- paste("01-", Gore.spr.MDS.sqrt.pts.2$Label, sep = "") #add dummy day to Survey
Gore.spr.MDS.sqrt.pts.2$Label <- as.Date(Gore.spr.MDS.sqrt.pts.2$Label, format = "%d-%b-%Y") #change survey to date
Gore.spr.MDS.sqrt.pts.2<- Gore.spr.MDS.sqrt.pts.2[order(Gore.spr.MDS.sqrt.pts.2$Label), ] #order by date
xmin <- min(Gore.spr.MDS.sqrt.pts.2$MDS1)*1.3
xmax <- max(Gore.spr.MDS.sqrt.pts.2$MDS1)*1.3
ymin <- min(Gore.spr.MDS.sqrt.pts.2$MDS2)*1.3
ymax <- max(Gore.spr.MDS.sqrt.pts.2$MDS2)*1.3
ggplot(Gore.spr.MDS.sqrt.pts, aes(x=MDS1, y=MDS2)) + xlim(xmin, xmax) + ylim(ymin, ymax) + coord_fixed(ratio = 1) + geom_point(cex=8) + geom_text(aes(label = Label), cex=3, vjust=2, hjust=1.6) + theme(legend.position = "none") + geom_path()
```

###Stacked abundance column plots for Gore system waterbirds

```{r}
Gore.stack <- input.data[input.data$System == "Gore", ]
Gore.stack$Group <- Taxonomy[match(Gore.stack$CommonName, Taxonomy$CommonName), 3]
```

```{r}
# Aggregate data by taxonomic group and survey, with survey and season variables for plotting
# plus add dummy dates for years not surveyed

Gore.stack.agg <- aggregate(data=Gore.stack, Count ~ Group + Survey + Season, FUN="sum") #aggregate count data by species and survey
#create dummy data for missing survey years for spring and summer
md.Group <- rep("Grebes", times = 8)
md.Survey <- c("Nov-2015","Nov-2016","Nov-2017","Nov-2019","Feb-2016","Feb-2017","Feb-2018","Feb-2020")
md.Season <- c(rep("spring", times = 4), rep("summer", times = 4))
md.Count <- rep(0, times = 8)
Missing.dates <- data.frame(md.Group, md.Survey, md.Season, md.Count)
colnames(Missing.dates) <- c("Group","Survey","Season","Count")
Gore.stack.agg <- rbind(Gore.stack.agg, Missing.dates)
Gore.stack.agg$SurvOrd <- as.character(Gore.stack.agg$Survey)
Gore.stack.agg$SurvOrd <- as.numeric(str_replace_all(Gore.stack.agg$SurvOrd, c("Feb-2010" = "1", "Feb-2011" = "2", "Feb-2012" = "3", "Feb-2013" = "4", "Feb-2014" = "5", "Feb-2015" = "6", "Feb-2016" = "7", "Feb-2017" = "8", "Feb-2018" = "9", "Feb-2019" = "10", "Feb-2020"=11, "Nov-2009" = "1", "Nov-2010" = "2", "Dec-2011" = "3", "Oct-2012" = "4", "Nov-2013"= "5", "Nov-2014" = "6", "Nov-2015" = "7", "Nov-2016" = "8", "Nov-2017" = "9", "Nov-2018" = "10", "Nov-2019" = "11", "Nov-2020" = "12")))
```

```{r}
# stacked column plots for Gore by season

#spring
Gore.stack.spr <- Gore.stack.agg[Gore.stack.agg$Season=="spring", ] #cut down to just spring data
Gore.stack.spr <- Gore.stack.spr[ order(Gore.stack.spr$SurvOrd), ]

ggplot(Gore.stack.spr, aes(x=reorder(Survey, SurvOrd), y=Count, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,25000, by=2500), limits=c(0,22500)) + labs(x="Survey", y="Abundance") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0))) + scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A"))

#summer
Gore.stack.sum <- Gore.stack.agg[Gore.stack.agg$Season=="summer", ] #cut down to just summer data
Gore.stack.sum <- Gore.stack.sum[ order(Gore.stack.sum$SurvOrd), ]

ggplot(Gore.stack.sum, aes(x=reorder(Survey, SurvOrd), y=Count, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,25000, by=2500), limits=c(0,22500)) + labs(x="Survey", y="Abundance") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0))) + scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#A2B5CD","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A")) #uses Date to reorder survey on x axis
```

###Stacked column plots for species richness at Gore

```{r}
Gore.stack.rich <- input.data.2[input.data.2$System == "Gore", ]
Gore.stack.rich$Group <- Taxonomy[match(Gore.stack.rich$CommonName, Taxonomy$CommonName), 3]
```

```{r}
#create matrix for examining data
Gore_matrix <- acast(Gore.stack.rich, Group + CommonName ~ Survey, value.var="Count", fun.aggregate = sum) #sums counts for each species and survey
```

```{r}
#Aggregate counts by common name, then count number of species within groups
Gore.stack.rich <- aggregate(data=Gore.stack.rich, Count ~ CommonName + Group + Survey + Season, FUN="sum") #aggregate count data by species and survey
Gore.stack.rich <- Gore.stack.rich[, c("Survey","Group","Season")] #restrict data to 3 columns
Gore.stack.rich <- count(Gore.stack.rich, c("Group","Survey","Season")) #count no. species
#craete dummy years
md.Group <- rep("Grebes", times = 8)
md.Survey <- c("Nov-2015","Nov-2016","Nov-2017","Nov-2019","Feb-2016","Feb-2017","Feb-2018","Feb-2020")
md.Season <- c(rep("spring", times = 4), rep("summer", times = 4))
md.freq <- rep(0, times = 8)
Missing.dates <- data.frame(md.Group, md.Survey, md.Season, md.freq)
colnames(Missing.dates) <- c("Group","Survey","Season","freq")
Gore.stack.rich <- rbind(Gore.stack.rich, Missing.dates)
Gore.stack.rich$SurvOrd <- as.character(Gore.stack.rich$Survey)
Gore.stack.rich$SurvOrd <- as.numeric(str_replace_all(Gore.stack.rich$SurvOrd, c("Feb-2010" = "1", "Feb-2011" = "2", "Feb-2012" = "3", "Feb-2013" = "4", "Feb-2014" = "5", "Feb-2015" = "6", "Feb-2016" = "7", "Feb-2017" = "8", "Feb-2018" = "9", "Feb-2019" = "10", "Nov-2009" = "1", "Nov-2010" = "2", "Dec-2011" = "3", "Oct-2012" = "4", "Nov-2013"= "5", "Nov-2014" = "6", "Nov-2015" = "7", "Nov-2016" = "8", "Nov-2017" = "9", "Nov-2018" = "10", "Nov-2019" = "11", "Nov-2020" = "12")))
```

```{r}
# stacked richness column plots for Gore by season

#spring
Gore.stack.rich.spr <- Gore.stack.rich[Gore.stack.rich$Season=="spring", ]
#cut down to just spring data
Gore.stack.rich.spr <- Gore.stack.rich.spr[order(Gore.stack.rich.spr$SurvOrd), ]

ggplot(Gore.stack.rich.spr, aes(x=reorder(Survey, SurvOrd), y=freq, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,40, by=10), limits=c(0,40)) + labs(x="Survey", y="Number of species") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0))) + scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A"))

#summer
Gore.stack.rich.sum <- Gore.stack.rich[Gore.stack.rich$Season=="summer", ] #cut down to just summer data
Gore.stack.rich.sum <- Gore.stack.rich.sum[ order(Gore.stack.rich.sum$SurvOrd), ]

ggplot(Gore.stack.rich.sum, aes(x=reorder(Survey, SurvOrd), y=freq, fill=Group)) + geom_bar(stat="identity", colour = "black") + scale_y_continuous(breaks = seq(0,40, by=10), limits=c(0,40)) + labs(x="Survey", y="Number of species") + theme (axis.text.x=element_text(angle=90)) + theme(axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) + theme(axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0))) + scale_fill_manual(values = c("#CD9B9B","#912CEE","#104E8B","#698B22","#00EEEE","#A2B5CD","#FFA500","#FFE1FF","#B4CDCD","#C1FFc1","#A52A2A"))
```

